import {Observable,Subject,merge,queueScheduler,from}from'rxjs';import {filter,observeOn,map,mergeMap,subscribeOn}from'rxjs/operators';import {isAction}from'redux';var v=Object.defineProperty;var x=(t,n,e)=>n in t?v(t,n,{enumerable:true,configurable:true,writable:true,value:e}):t[n]=e;var a=(t,n,e)=>x(t,typeof n!="symbol"?n+"":n,e);var c=class extends Observable{constructor(e,o){super(r=>{let i=this.__notifier.subscribe(r);return i&&!i.closed&&r.next(this._value),i});a(this,"_value");a(this,"__notifier",new Subject);a(this,"_inputSubscription");this._value=o,this._inputSubscription=e.subscribe(r=>{r!==this._value&&(this._value=r,this.__notifier.next(r));});}get value(){return this._value}unsubscribe(){this._inputSubscription.unsubscribe(),this.__notifier.complete();}};function _(...t){let n=(...e)=>merge(...t.map(o=>{let r=o(...e);if(!r)throw new TypeError(`combineEpics: one of the provided Epics "${o.name||"<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`);return r}));try{Object.defineProperty(n,"name",{value:`combineEpics(${t.map(e=>e.name||"<anonymous>").join(", ")})`});}catch{}return n}var g=()=>{},T=typeof console=="object"&&typeof console.warn=="function"?(...t)=>console.warn(...t):()=>{};var u=t=>{T(`redux-observable | WARNING: ${t}`);};function k(t={}){let n=queueScheduler.constructor,e=new n(queueScheduler.schedulerActionCtor);if(process.env.NODE_ENV!=="production"&&typeof t=="function")throw new TypeError("Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\n\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware");let o=new Subject,r,i=d=>{process.env.NODE_ENV!=="production"&&r&&u(`this middleware is already associated with a store. createEpicMiddleware should be called for every store.

Learn more: https://goo.gl/2GQ7Da`),r=d;let f=new Subject,b=new Subject,S=f.asObservable().pipe(observeOn(e)),y=new c(b.pipe(observeOn(e)),r.getState());return o.pipe(map(p=>{let s=p(S,y,t.dependencies);if(!s)throw new TypeError(`Your root Epic "${p.name||"<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`);return s}),mergeMap(p=>from(p).pipe(subscribeOn(e),observeOn(e)))).subscribe(r.dispatch),p=>s=>{let h=p(s);return b.next(r.getState()),f.next(s),h}};return i.run=d=>{process.env.NODE_ENV!=="production"&&!r&&u("epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first."),o.next(d);},i}function G(...t){let n=t.length;return process.env.NODE_ENV!=="production"&&(n===0&&u("ofType was called without any types!"),t.some(e=>e==null)&&u("ofType was called with one or more undefined or null values!")),filter(n===1?e=>isAction(e)&&e.type===t[0]:e=>{if(isAction(e)){for(let o=0;o<n;o++)if(e.type===t[o])return  true}return  false})}
export{c as StateObservable,g as __FOR_TESTING__resetDeprecationsSeen,_ as combineEpics,k as createEpicMiddleware,G as ofType};//# sourceMappingURL=redux-observable.mjs.map
//# sourceMappingURL=redux-observable.mjs.map